package org.scalajs.dom.experimental

import org.scalajs.dom.raw.{DOMError, EventTarget}
import scala.scalajs.js
import scala.scalajs.js.annotation.JSName

@js.native
trait MediaStreamTrack extends EventTarget{

  /**
   * Is a Boolean value with a value of true if the track is enabled, that is
   * allowed to render the media source stream; or false if it is disabled,
   * that is not rendering the media source stream but silence and blackness.
   * If the track has been disconnected, this value can be changed but has no
   * more effect.
   *
   * MDN
   */
  val enabled: Boolean = js.native

  /**
   * READONLY Returns a DOMString containing a unique identifier (GUID) for the
   * track; it is generated by the browser.
   *
   * MDN
   */
  val id: String = js.native

  /**
   * READONLY Returns a DOMString set to "audio" if the track is an audio track
   * and to "video", if it is a video track. It doesn't change if the track is
   * deassociated from its source.
   *
   * MDN
   */
  val kind: String = js.native

  /**
   * READONLY Returns a DOMString containing a user agent-assigned label that
   * identifies the track source, as in "internal microphone". The string may
   * be left empty and is empty as long as no source has been connected. When
   * the track is deassociated from its source, the label is not changed.
   *
   * MDN
   */
  val label: String = js.native

  /**
   * READONLY Returns a Boolean value with a value of true if the track is
   * muted, false otherwise.
   *
   * MDN
   */
  val muted: Boolean = js.native

  /**
   * READONLY Returns a Boolean value with a value of true if the track is
   * readonly (such a video file source or a camera that settings can't be
   * modified),false otherwise.
   *
   * MDN
   */
  val readonly: Boolean = js.native

  /**
   * READONLY Returns an enumerated value giving the status of the track.It
   * takes one of the following values:
   *
   *    "live" which indicates that an input is connected and does its
   *    best-effort in providing real-time data. In that case, the output of
   *    data can be switched on or off using the MediaStreamTrack.enabled
   *    attribute.
   *
   *    "ended" which indicates that the input is not giving any more data
   *    and will never provide new data.
   *
   * MDN
   */
  val readyState : String = js.native

  /**
   * READONLY Returns a boolean value with a value of true if the track is
   * sourced by a RTCPeerConnection, false otherwise.
   *
   * MDN
   */
  val remote : Boolean = js.native

  /**
   * Is a EventHandler containing the action to perform when an started event
   * is fired on the object, that is when a new MediaStreamTrack object is
   * added.
   *
   * MDN
   */
  val onstarted: js.Function0[Any] = js.native

  /**
   * Is a EventHandler containing the action to perform when an mute event is
   * fired on the object, that is when the streaming is terminating.
   *
   * MDN
   */
  val onmute: js.Function0[Any] = js.native

  /**
   * Is a EventHandler containing the action to perform when an unmute event
   * is fired on the object, that is when a  MediaStreamTrack object is removed
   * from it.
   *
   * MDN
   */
  val onunmute: js.Function0[Any] = js.native

  /**
   * Is a EventHandler containing the action to perform when an overconstrained
   * event is fired on the object, that is when a  MediaStreamTrack object is
   * removed from it.
   *
   * MDN
   */
  val onoverconstrained: js.Function0[Any] = js.native

  /**
   * Is a EventHandler containing the action to perform when an ended event is
   * fired on the object, that is when a  MediaStreamTrack object is removed
   * from it.
   *
   * MDN
   */
  val oneended: js.Function0[Any] = js.native

  def getConstraints(): Unit = js.native

  def applyConstraints(): Unit = js.native

  def getSettings(): Unit = js.native

  def getCapabilities(): Unit = js.native

  /**
   * Stops playing the source associated to the track, both the source and the
   * track are deassociated. The track state is set to ended.
   *
   * MDN
   */
  def stop(): Unit = js.native
}

object MediaStreamTrack{

  object kind{
    val video = "video"
    val audio = "audio"
  }

  object readyState{
    val live = "live"
    val ended = "ended"
  }

  def apply(
     enabled: js.UndefOr[Boolean] = js.undefined,
     id: js.UndefOr[String] = js.undefined,
     kind: js.UndefOr[String] = js.undefined,
     label: js.UndefOr[String] = js.undefined,
     muted: js.UndefOr[Boolean] = js.undefined,
     readonly: js.UndefOr[Boolean] = js.undefined,
     readyState: js.UndefOr[String] = js.undefined,
     remote: js.UndefOr[Boolean] = js.undefined,
     onstarted: js.UndefOr[js.Function0[Any]] = js.undefined,
     onmute: js.UndefOr[js.Function0[Any]] = js.undefined,
     onunmute: js.UndefOr[js.Function0[Any]] = js.undefined,
     onoverconstrained: js.UndefOr[js.Function0[Any]] = js.undefined,
     oneended: js.UndefOr[js.Function0[Any]] = js.undefined):MediaStreamTrack = {
    val result = js.Dynamic.literal()
    enabled.foreach(result.enabled = _)
    id.foreach(result.id = _)
    kind.foreach(result.kind = _)
    label.foreach(result.label = _)
    muted.foreach(result.muted = _)
    readonly.foreach(result.readonly = _)
    readyState.foreach(result.readyState = _)
    remote.foreach(result.remote = _)
    onstarted.foreach(result.onstarted = _)
    onmute.foreach(result.onmute = _)
    onunmute.foreach(result.onunmute = _)
    onoverconstrained.foreach(result.onoverconstrained = _)
    oneended.foreach(result.oneended = _)
    result.asInstanceOf[MediaStreamTrack]
  }
}

/**
 * The MediaStream
 *
 * MDN
 *
 */
@js.native
class MediaStream() extends EventTarget {

  /**
   * READONLY A Boolean value that returns true if the MediaStream is
   * active, or false otherwise.
   *
   * MDN
   */
  val active: Boolean = js.native

  /**
   * READONLY Is a Boolean value set to true if the ended event has been
   * fired on the object, meaning that the stream has been completely read,
   * or false if the end of the stream has not been reached.
   *
   * MDN
   */
  val ended: Boolean = js.native

  /**
   * READONLY Is a DOMString containing 36 characters denoting a universally
   * unique identifier (UUID) for the object.
   *
   * MDN
   */
  val id: String = js.native

  /**
   * Is an EventHandler containing the action to perform when an active event
   * is fired when a MediaStream object becomes active.
   *
   * MDN
   */
  val onactive: js.Function0[Any] = js.native

  /**
   * Is an EventHandler containing the action to perform when an addtrack event
   * is fired when a new MediaStreamTrack object is added.
   *
   * MDN
   */
  val onaddtrack: js.Function0[Any] = js.native

  /**
   * Is an EventHandler containing the action to perform when an inactive event
   * is fired when a MediaStream object becomes inactive.
   *
   * MDN
   */
  val oninactive: js.Function0[Any] = js.native

  /**
   * Is an EventHandler containing the action to perform when an removetrack
   * event is fired when a  MediaStreamTrack object is removed from it.
   *
   * MDN
   */
  val onremovetrack: js.Function0[Any] = js.native

  /**
   * Stores a copy of the MediaStreamTrack given as argument. If the track has
   * already been added to the MediaStream object, nothing happens; if the
   * track is in the finished state - that is, has already reached its end -
   * the exception INVALID_STATE_RAISE is raised.
   *
   * MDN
   */
  def addTrack(track:MediaStreamTrack): Unit = js.native

  /**
   * Returns a list of the MediaStreamTrack objects stored in the MediaStream
   * object that have their kind attribute set to "audio". The order is not
   * defined, and may not only vary from one browser to another, but also from
   * one call to another..
   *
   * MDN
   */
  def getAudioTracks(): MediaStreamTrack = js.native

  /**
   * Returns the track whose ID corresponds to the one given in parameters,
   * trackid. If no parameter is given, or if no track with that ID does exist,
   * it returns null. If several tracks have the same ID, it returns the first
   * one.
   *
   * MDN
   */
  def getTrackById(id:String): MediaStreamTrack = js.native

  /**
   * Returns a list of all MediaStreamTrack objects stored in the MediaStream
   * object, regardless of the value of the kind attribute. The order is not
   * defined, and may not only vary from one browser to another, but also from
   * one call to another.
   *
   * MDN
   */
  def getTracks(): MediaStreamTrack = js.native

  /**
   * Returns a list of the MediaStreamTrack objects stored in the MediaStream
   * object that have their kind attribute set to "video". The order is not
   * defined, and may not only vary from one browser to another, but also from
   * one call to another.
   *
   * MDN
   */
  def getVideoTracks(): MediaStreamTrack = js.native

  /**
   * Removes the MediaStreamTrack given as argument. If the track is not part
   * of the MediaStream object, nothing happens; if the track is in the
   * finished state - that is, it has already reached its end - the exception
   * INVALID_STATE_RAISE is raised.
   *
   * MDN
   */
  def removeTrack(track:MediaStreamTrack): Unit = js.native
}

@js.native
trait RTCIdentityAssertion extends js.Object{
  val idp:String = js.native
  val name:String = js.native
}

object RTCIdentityAssertion{
  def apply(
     idp: js.UndefOr[String] = js.undefined,
     name: js.UndefOr[String] = js.undefined
     ):RTCIdentityAssertion ={
    val result = js.Dynamic.literal()
    idp.foreach(result.idp = _)
    name.foreach(result.name = _)
    result.asInstanceOf[RTCIdentityAssertion]
  }
}

@js.native
trait MediaConstraints extends js.Object{
  var audio:Boolean = js.native
  var video:Boolean = js.native
}

object MediaConstraints {
  def apply(
             video: js.UndefOr[Boolean] = js.undefined,
             audio: js.UndefOr[Boolean] = js.undefined
             ): MediaConstraints = {
    val result = js.Dynamic.literal()
    video.foreach(result.video = _)
    audio.foreach(result.audio = _)
    result.asInstanceOf[MediaConstraints]
  }
}

@js.native
trait RTCIceServer{
  var url:String
  var username:String
  var credential:String
}

object RTCIceServer {
  def apply(
             url: js.UndefOr[String] = js.undefined,
             username: js.UndefOr[String] = js.undefined,
             credential: js.UndefOr[String] = js.undefined
             ): RTCIceServer = {
    val result = js.Dynamic.literal()
    url.foreach(result.url = _)
    username.foreach(result.username = _)
    credential.foreach(result.credential = _)
    result.asInstanceOf[RTCIceServer]
  }
}

@js.native
trait RTCConfiguration{
  var iceServers:js.Array[RTCIceServer]
}

object RTCConfiguration {
  def apply(
             iceServers: js.UndefOr[js.Array[RTCIceServer]] = js.undefined
             ): RTCConfiguration = {
    val result = js.Dynamic.literal()
    iceServers.foreach(result.iceServers = _)
    result.asInstanceOf[RTCConfiguration]
  }
}

@JSName("RTCSessionDescription")
@js.native
class RTCSessionDescription(options: js.Dynamic) extends js.Object {

  /**
   * This constructor returns a new RTCSessionDescription. The parameter is a
   * RTCSessionDescriptionInit dictionary containing the (optional) values
   * for the two properties. Any values not specified in the dictionary will
   * be initialized to null.
   *
   * MDN
   */
  //def this(options: js.Dynamic) = this(options)

  /**
   * An enum of type RTCSdpType describing the session description's type.
   *
   * MDN
   */
  var `type`:String = js.native

  /**
   * A DOMString containing the SDP format describing the session.
   *
   * MDN
   */
  var sdp:String = js.native

  /**
   * Returns a JSON description of the object. The values of both properties,
   * type and {domxref("RTCSessionDescription.sdp", "sdp")}}, are contained
   * in the generated JSON.
   *
   * MDN
   */
  def toJson():js.Any = js.native
}

object RTCSdpType{
  val offer = "offer"
  val pranswer = "pranswer"
  val answer = "answer"
  val rollback = "rollback"
}

@js.native
trait RTCIceCandidate extends js.Object{
  var candidate: String = js.native
  var sdpMLineIndex: Int = js.native
  var sdpMid:String = js.native
}

object RTCIceCandidate {
  def apply(
     candidate: js.UndefOr[String] = js.undefined,
     sdpMLineIndex: js.UndefOr[Int] = js.undefined,
     sdpMid: js.UndefOr[String] = js.undefined
     ): RTCIceCandidate = {
    val result = js.Dynamic.literal()
    candidate.foreach(result.candidate = _)
    sdpMLineIndex.foreach(result.sdpMLineIndex = _)
    sdpMid.foreach(result.sdpMid = _)
    result.asInstanceOf[RTCIceCandidate]
  }
}

// TODO: ..
// https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel
trait RTCDataChannel {
  // TODO: ...
}

//https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection
trait RTCDataChannelInit{
  // TODO: ..
}

//https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection
trait RTCDTMFSender{
  // TODO: ..
}

//https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection
trait RTCStatsReport{
  // TODO: ..
}

/**
 * The MediaStream
 *
 * MDN
 *
 */
@JSName("RTCPeerConnection")
@js.native
class RTCPeerConnection(configuration:RTCConfiguration, constraints:js.UndefOr[MediaConstraints] = js.undefined) extends EventTarget {

  //def this(configuration:RTCConfiguration, constraints:js.UndefOr[MediaConstraints] = js.undefined) = this(configuration, constraints)

  /**
   * READONLY Returns an enum of type RTCIceConnectionState that describes the
   * ICE connection state for the connection. When this value changes, a
   * iceconnectionstatechange event is fired on the object. The possible values
   * are:
   *    "new": the ICE agent is gathering addresses or waiting for remote
   *    candidates (or both).
   *
   *    "checking": the ICE agent has remote candidates, on at least one
   *    component, and is check them, though it has not found a connection yet.
   *    At the same time, it may still be gathering candidates.
   *
   *    "connected": the ICE agent has found a usable connection for each
   *    component, but is still testing more remote candidates for a better
   *    connection. At the same time, it may still be gathering candidates.
   *
   *    "completed": the ICE agent has found a usable connection for each
   *    component, and is no more testing remote candidates.
   *
   *    "failed": the ICE agent has checked all the remote candidates and
   *    didn't find a match for at least one component. Connections may have
   *    been found for some components.
   *
   *    "disconnected": liveness check has failed for at least one component.
   *    This may be a transient state, e. g. on a flaky network, that can
   *    recover by itself.
   *
   *    "closed": the ICE agent has shutdown and is not answering to requests.
   *
   * MDN
   */
  val iceConnectionState: String = js.native

  /**
   * READONLY Returns an enum of type RTCIceGatheringState that describes the
   * ICE gathering state for the connection. The possible values are:
   *    "new": the object was just created, and no networking has occurred yet.
   *
   *    "gathering": the ICE engine is in the process of gathering candidates
   *    for this connection.
   *
   *    "complete": the ICE engine has completed gathering. Events such as
   *    adding a new interface or a new TURN server will cause the state to
   *    go back to gathering.
   *
   * MDN
   */
  val iceGatheringState: String = js.native

  /**
   * READONLY Returns a RTCSessionDescription describing the session for the
   * local end of the connection. If it has not yet been set, it can be null.
   *
   * MDN
   */
  val localDescription: RTCSessionDescription = js.native

  /**
   * Returns a RTCIdentityAssertion, that is a couple of a domain name (idp)
   * and a name (name) representing the identity of the remote peer of this
   * connection, once set and verified. If no peer has yet been set and
   * verified, this property will return null. Once set, via the appropriate
   * method, it can't be changed.
   *
   * MDN
   */
  val peerIdentity: RTCIdentityAssertion = js.native

  /**
   * Returns a RTCSessionDescription describing the session for the remote end
   * of the connection. If it has not yet been set, it can be null.
   *
   * MDN
   */
  val remoteDescription: RTCSessionDescription = js.native

  /**
   * READONLY Returns an enum of type RTCSignalingState that describes the
   * signaling state of the local connection. This state describes the SDP
   * offer, that defines the configuration of the connections like the
   * description of the locally associated objects of type MediaStream, the
   * codec/RTP/RTCP options, the candidates gathered by the ICE Agent. When
   * this value changes, a signalingstatechange event is fired on the object.
   * The possible values are:
   *
   *    "stable": there is no SDP offer/answer exchange in progress. This is
   *    also the initial state of the connection.
   *
   *    "have-local-offer": the local end of the connection has locally applied
   *    a SDP offer.
   *
   *    "have-remote-offer": the remote end of the connection has locally
   *    applied a SDP offer.
   *
   *    "have-local-pranswer": a remote SDP offer has been applied, and a SDP
   *    pranswer applied locally.
   *
   *    "have-remote-pranswer": a local SDP offer has been applied, and a SDP
   *    pranswer applied remotely.
   *
   *    "closed": the connection is closed.
   *
   * MDN
   */
  val signalingState: String = js.native

  /**
   * Is the event handler called when the addstream event is received. Such an
   * event is sent when a MediaStream is added to this connection by the
   * remote peer. The event is sent immediately after the call
   * RTCPeerConnection.setRemoteDescription() and doesn't wait for the result
   * of the SDP negotiation.
   *
   * MDN
   */
  val onaddstream: js.Function0[Any] = js.native

  /**
   * Is the event handler called when the datachannel event is received. Such
   * an event is sent when a RTCDataChannel is added to this connection.
   *
   * MDN
   */
  val ondatachannel: js.Function0[Any] = js.native

  /**
   * Is the event handler called when the icecandidate event is received. Such
   * an event is sent when a RTCICECandidate object is added to the script..
   *
   * MDN
   */
  val onicecandidate: js.Function0[Any] = js.native

  /**
   * Is the event handler called when the iceconnectionstatechange event is
   * received. Such an event is sent when the value of iceConnectionState
   * changes.
   *
   * MDN
   */
  val oniceconnectionstatechange: js.Function0[Any] = js.native

  /**
   * Is the event handler called when the identityresult event is received.
   * Such an event is sent when an identity assertion is generated, via
   * getIdentityAssertion(), or during the creation of an offer or an answer.
   *
   * MDN
   */
  val onidentityresult: js.Function0[Any] = js.native

  /**
   * Is the event handler called when the idpassertionerror event is received.
   * Such an event is sent when the associated identity provider (IdP)
   * encounters an error while generating an identity assertion.
   *
   * MDN
   */
  val onidpassertionerror: js.Function0[Any] = js.native

  /**
   * Is the event handler alled when the idpvalidationerror event is received.
   * Such an event is sent when the associated identity provider (IdP)
   * encounters an error while validating an identity assertion.
   *
   * MDN
   */
  val onidpvalidationerror: js.Function0[Any] = js.native

  /**
   * Is the event handler called when the negotiationneeded event, sent by the
   * browser to inform that negotiation will be required at some point in the
   * future, is received.
   *
   * MDN
   */
  val onnegotiationneeded: js.Function0[Any] = js.native

  /**
   * Is the event handler called when the peeridentity event, sent when a peer
   * identity has been set and verified on this connection, is received.
   *
   * MDN
   */
  val onpeeridentity: js.Function0[Any] = js.native

  /**
   * Is the event handler called when the removestream event, sent when a
   * MediaStream is removed from this connection, is received.
   *
   * MDN
   */
  val onremovestream: js.Function0[Any] = js.native

  /**
   * Is the event handler called when the signalingstatechange event, sent when
   * the value of signalingState changes, is received.
   *
   * MDN
   */
  val onsignalingstatechange: js.Function0[Any] = js.native

  /**
   * Creates an offer that is a request to find a remote peer with a specific
   * configuration. The two first parameters of this methods are respectively
   * success and error callbacks, the optional third one are options the user
   * want to have, like audio or video streams.
   *
   * MDN
   */
  def createOffer(success:js.Function1[RTCSessionDescription, Any], error:js.Function1[DOMError, Any], options:js.UndefOr[MediaConstraints] = js.undefined): Unit = js.native

  /**
   * Creates an answer to the offer received by the remote peer, in a two-part
   * offer/answer negotiation of a connection. The two first parameters are
   * respectively success and error callbacks, the optional third one represent
   * options for the answer to be created.
   *
   * MDN
   */
  def createAnswer(success:js.Function1[RTCSessionDescription, Any], error:js.Function1[DOMError, Any], options:js.UndefOr[MediaConstraints] = js.undefined): Unit = js.native

  /**
   * Changes the local description associated with the connection. The
   * description defines the properties of the connection like its codec. The
   * connection is affected by this change and must be able to support both
   * old and new descriptions. The method takes three parameters, a
   * RTCSessionDescription object to set, and two callbacks, one called if
   * the change of description succeeds, another called if it failed.
   *
   * MDN
   */
  def setLocalDescription(description:RTCSessionDescription): Unit = js.native

  /**
   * Changes the remote description associated with the connection. The
   * description defines the properties of the connection like its codec.
   * The connection is affected by this change and must be able to support
   * both old and new descriptions. The method takes three parameters, a
   * RTCSessionDescription object to set, and two callbacks, one called if
   * the change of description succeeds, another called if it failed.
   *
   * MDN
   */
  def setRemoteDescription(description:RTCSessionDescription): Unit = js.native

  /**
   * The updateIce method updates the ICE Agent process of gathering local
   * candidates and pinging remote candidates. If there is a mandatory
   * constraint called "IceTransports" it will control how the ICE engine
   * can act. This can be used to limit the use to TURN candidates by a callee
   * to avoid leaking location information prior to the call being accepted.
   * This call may result in a change to the state of the ICE Agent, and may
   * result in a change to media state if it results in connectivity being
   * established
   *
   * MDN
   */
  def updateIce(configuration: js.UndefOr[RTCConfiguration] = js.undefined, constraints: js.UndefOr[MediaConstraints] = js.undefined): Unit = js.native

  /**
   * The addIceCandidate() method provides a remote candidate to the ICE Agent.
   * In addition to being added to the remote description, connectivity checks
   * will be sent to the new candidates as long as the "IceTransports"
   * constraint is not set to "none". This call will result in a change to the
   * connection state of the ICE Agent, and may result in a change to media
   * state if it results in different connectivity being established.
   *
   * MDN
   */
  def addIceCandidate(candidate:RTCIceCandidate, success:js.Function1[Any, Any], error:js.Function1[DOMError, Any]): Unit = js.native

  def getConfiguration(): RTCConfiguration = js.native

  /**
   * Returns an array of MediaStream associated with the local end of the
   * connection. The array may be empty.
   *
   * MDN
   */
  def getLocalStreams(): js.Array[MediaStream] = js.native

  /**
   * Returns an array of MediaStream associated with the remote end of the
   * connection. The array may be empty.
   *
   * MDN
   */
  def getRemoteStreams(): js.Array[MediaStream] = js.native

  /**
   * Returns the MediaStream with the given id that is associated with local
   * or remote end of the connection. If no stream matches, it returns null.
   *
   * MDN
   */
  def getStreamById(id: String): MediaStream = js.native

  /**
   * Adds a MediaStream as a local source of audio or video. If the
   * negotiation already happened, a new one will be needed for the remote
   * peer to be able to use it.
   *
   * MDN
   */
  def addStream(stream: MediaStream): Unit = js.native

  /**
   * Removes a MediaStream as a local source of audio or video. If the
   * negotiation already happened, a new one will be needed for the remote
   * peer to stop using it.
   *
   * MDN
   */
  def removeStream(stream: MediaStream): Unit = js.native

  /**
   * Abruptly closes a connection.
   *
   * MDN
   */
  def close(): Unit = js.native

  /**
   * Creates a new RTCDataChannel associated with this connection. The method
   * takes a dictionary as parameter, with the configuration required for the
   * underlying data channel, like its reliability.
   *
   * MDN
   */
  def createDataChannel(label:String, options:js.UndefOr[RTCDataChannelInit] = js.undefined): RTCDataChannel = js.native

  /**
   * Creates a new RTCDTMFSender, associated to a specific MediaStreamTrack,
   * that will be able to send DTMF phone signaling over the connection.
   *
   * MDN
   */
  def createDTMFSender(): RTCDTMFSender = js.native

  /**
   * Creates a new RTCStatsReport that contains and allows access to statistics
   * regarding the connection.
   *
   * MDN
   */
  def getStats(): RTCStatsReport = js.native

  /**
   * Sets the Identity Provider (IdP) to the triplet given in parameter: its
   * name, the protocol used to communicate with it (optional) and an optional
   * username. The IdP will be used only when an assertion will be needed.
   *
   * MDN
   */
  def setIdentityProvider(id: js.Any): Unit = js.native

  /**
   * Initiates the gathering of an identity assertion. This has an effect only
   * if the signalingState is not "closed". It is not expected for the
   * application dealing with the RTCPeerConnection: this is automatically
   * done; an explicit call only allows to anticipate the need.
   *
   * MDN
   */
  def getIdentityAssertion(id: js.Any): Unit = js.native
}


@js.native
trait NavigatorGetUserMedia extends js.Object {
  def getUserMedia(constraints: MediaConstraints, callback:(DOMError, MediaStream) => Unit):Unit = js.native
}
